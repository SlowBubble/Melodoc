
export interface FractionApi {
  numer?: Int,
  denom?: PositiveInt,
}

type Int = number;
type PositiveInt = number;

export function makeFrac(...args: Array<number>) {
  if (args.length > 2 || args.length < 1) {
    throw 'makeFrac can only have 1 or 2 arguments.';
  }
  const numer = args[0];
  let denom = 1;
  if (args.length === 2) {
    denom = args[1];
  }
  return new Frac({numer: numer, denom: denom});
}

export function fromString(str: string) {
  const [numerStr, denomStr] = str.split('/');
  const numer = parseInt(numerStr);
  const denom = parseInt(denomStr);
  if (isNaN(numer) || isNaN(denom)) {
    throw new Error('Unable to parse this as fraction: ' + str);
  }
  return makeFrac(numer, denom);
}

export class Frac {
  numer: number;
  denom: number;
  constructor({numer = 0, denom = 1}: FractionApi) {
    if (denom == 0) {
      throw new Error("denominator must be non-zero.");
    }
    // Obtaining a unique rep.
    if (denom < 0) {
      numer = -numer;
      denom = -denom;
    }
    const gcd = computeGcd(numer, denom);
    this.numer = numer / gcd;
    this.denom = denom / gcd;
  }

  getDenom() {
    return this.denom;
  }

  getNumer() {
    return this.numer;
  }

  isWhole() {
    return this.denom === 1;
  }

  plus(f2: FractionApi | number) {
    const f1 = this;
    const frac2 = typeof f2 === 'number' ? makeFrac(f2) : new Frac(f2);
    return new Frac({
      numer: f1.numer * frac2.denom + frac2.numer * f1.denom,
      denom: f1.denom * frac2.denom,
    });
  }

  minus(f2: FractionApi | number) {
    const f1 = this;
    const frac2 = typeof f2 === 'number' ? makeFrac(f2) : new Frac(f2);
    return f1.plus(frac2.negative());
  }

  times(f2: FractionApi | number) {
    const f1 = this;
    const frac2 = typeof f2 === 'number' ? makeFrac(f2) : new Frac(f2);
    return new Frac({
      numer: f1.numer * frac2.numer,
      denom: f1.denom * frac2.denom,
    });
  }

  over(f2: FractionApi | number) {
    const f1 = this;
    const frac2 = typeof f2 === 'number' ? makeFrac(f2) : new Frac(f2);
    return new Frac({
      numer: f1.numer * frac2.denom,
      denom: f1.denom * frac2.numer,
    });
  }

  negative() {
    return new Frac({
      numer: -this.numer,
      denom: this.denom,
    });
  }

  toString() {
    return `${this.numer}/${this.denom}`;
  }

  toFloat() {
    return this.numer / this.denom;
  }

  equals(f2: FractionApi | number) {
    const frac2 = typeof f2 === 'number' ? makeFrac(f2) : new Frac(f2);
    return this.numer === frac2.numer && this.denom === frac2.denom;
  }

  lessThan(f2: FractionApi | number) {
    // Assumes that denom is > 0 always.
    const frac2 = typeof f2 === 'number' ? makeFrac(f2) : new Frac(f2);
    return this.numer * frac2.denom < frac2.numer * this.denom;
  }
  leq(frac2: FractionApi) {
    return this.lessThan(frac2) || this.equals(frac2);
  }

  geq(frac2: FractionApi) {
    return !this.lessThan(frac2);
  }

  greaterThan(frac2: FractionApi) {
    return !this.leq(frac2);
  }

  // weaklyInside(left: FractionApi, right: FractionApi) {
  //   return left.leq(this) && this.leq(right);
  // }

  // strictlyInside(left: FractionApi, right: FractionApi) {
  //   return left.lessThan(this) && this.lessThan(right);
  // }

  fractionalPart() {
    return this.minus(this.wholePart());
  }

  wholePart() {
    return Math.floor(this.toFloat());
  }
}

function computeGcd(x: number, y: number) {
  x = Math.abs(x);
  y = Math.abs(y);
  while(y) {
    var t = y;
    y = x % y;
    x = t;
  }
  return x;
}